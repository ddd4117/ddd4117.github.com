<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>os on 1o2o3o&#39;s Tech Blog</title>
    <link>https://ddd4117.github.io/tags/os/</link>
    <description>Recent content in os on 1o2o3o&#39;s Tech Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Sun, 09 May 2021 23:51:47 +0900</lastBuildDate><atom:link href="https://ddd4117.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[OS] 8장 - Memory Management</title>
      <link>https://ddd4117.github.io/2021/05/os-8%EC%9E%A5-memory-management/</link>
      <pubDate>Sun, 09 May 2021 23:51:47 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/05/os-8%EC%9E%A5-memory-management/</guid>
      <description>Logical vs Physical Address   Logical
 프로세스마다 독립적으로 가지는 주소 공간 각 프로세스마다 0번지부터 시작 CPU가 보는 주소는 logical address  instruction 내에 있는 주소는 logical address이고 실행할 때 physical address로 주소변환을 함      Physical
 메모리에 실제 올라가는 위치    주소 바인딩 : 주소를 결정하는 것 Symbolic Address → Logical Address → Physical Address
  주소 바인딩(Address Binding)  Compile time binding  물리적 메모리 주소가 컴파일 시 알려짐 시작 위치 변경시 재컴파일 컴파일러는 **절대 코드(absolute code)**생성 프로그램이 하나만 실행되는 옛날 컴퓨터에서 사용   Load time binding  Loader의 책임하에 물리적 메모리 주소 부여 컴파일러가 **재배치가능코드(relocatable code)**를 생성한 경우 가능 메모리에 비어있는 곳에 배치   Execution time binding(=Runtime binding)  수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음 CPU가 주소를 참조할 때마다 binding을 점검 하드웨어적인 지원이 필요    Memory-Management Unit(MMU)  logical address → physical address로 변환하는 장치(hardware device) base register + logical address limit register : 메모리 크기 → 다른 메모리의 주소를 접근하지 않기 위해 user program은 logical address만을 다루며 실제 physical address를 알 필요가 없음  Dynamic Relocation Dynamic Loading  프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것 memory utilization의 향상 가끔씩 사용되는 많은 양의 코드의 경우 유용 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS는 라이브러리를 통해 지원 가능)  Overlay(Manual Overlay)  메모리에 프로세스의 부분 중 필요한 정보만을 올림 프로세스의 크기가 메모리보다 클 때 유용 운영체제의 지원없이 사용자에 의해 구현 Dynamic Loading과 다른 점은 운영체제의 지원을 받냐 안받냐의 차이  Swapping  프로세스를 메모리에서 backing store로 쫓아내는 것 backing store(=swap area)  디스크 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간   Swap in / Swap out  일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정 priority-based CPU scheduling algorithm  priority가 낮은 프로세스를 swapped out priority가 높은 프로세스를 swapped in   swap in이 효율적으로 사용되려면 runtime binding이 되어야 함 compile/load time의 경우 원래 메모리 위치로 swap in 해야 함 swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임    Dynamic Linking  Linking을 실행 시간(execution time)까지 미루는 기법 Static linking  라이브러리가 프로그램의 실행 파일 코드에 포함 실행 파일의 크기가 커짐 동일한 라이브러리를 각각 프로세스가 메모리에 올리므로 메모리 낭비   Dynamic linking  라이브러리가 실행시 link됨 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어 옴 운영체제의 도움이 필요    Allocation of Physical Memory  메모리는 일반적으로 두 영역으로 나뉘어 사용  OS 상주 영역  interrupt vector   사용자 프로세스 영역   사용자 영역 할당 방법  Contiguous allocation  Fixed partition allocation Variable partition allocation   Non-Contiguous allocation  Paging Segmentation Paged Segmentation      Contiguous allocation 고정분할 방식  물리적 메모리를 몇 개의 영구적 파티션으로 나눔 분할의 크기가 모두 동일한 방식과 서로 다른 방식이 존재 분할당 하나의 프로그램 적재 Internal fragmentation과 external fragmentation 발생  가변분할 방식  프로그램이 실행될 때마다 크기를 고려해서 할당 분할의 크기, 개수가 동적으로 변함 기술적 관리 기법 필요 external fragmentation 발생  외부 파편(External Fragmentation)  프로그램 크기보다 파티션의 크기가 작은 경우 아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 구간  내부 파편(Internal Fragmentation)  프로그램 크기보다 파티션의 크기가 큰 경우 하나의 파티션 내부에서 발생하는 사용되지 않는 메모리 조각 특정 프로그램에 배정되었지만 사용되지 않는 공간  Hole  가용 메모리 공간 다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음 프로세스가 도착하면 수용가능한 hole을 할당 운영체제는 다음 정보를 유지  할당 공간 : 사용중인 공간 가용 공간 : 사용가능 공간    가장 적절한 hole을 찾는 문제  First-fit  Size가 n이상인 것 중 최초로 찾아지는 hole에 할당   Best-fit  Size가 n이상인 것 중 가장 작은 hole을 찾아서 할당 sorting이 되어있지 않은 경우 모든 hole을 탐색 많은 수의 아주 작은 hole들 생성   Worst-fit  가장 큰 hole에 할당 모든 리스트 탐색 상대적으로 큰 hole 발생    First-fit과 best-fit이 worst-fit보다 속도와 공간 이용률 측면에서 효과적</description>
    </item>
    
    <item>
      <title>[OS] 7장 - Deadlock</title>
      <link>https://ddd4117.github.io/2021/05/os-7%EC%9E%A5-deadlock/</link>
      <pubDate>Tue, 04 May 2021 22:36:34 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/05/os-7%EC%9E%A5-deadlock/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[OS] 6장 - Process Synchronization</title>
      <link>https://ddd4117.github.io/2021/05/os-6%EC%9E%A5-process-synchronization/</link>
      <pubDate>Mon, 03 May 2021 22:51:50 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/05/os-6%EC%9E%A5-process-synchronization/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[OS] 5장 - CPU 스케쥴링</title>
      <link>https://ddd4117.github.io/2021/04/os-5%EC%9E%A5-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/</link>
      <pubDate>Mon, 19 Apr 2021 22:03:58 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/04/os-5%EC%9E%A5-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[OS] 4장 - 프로세스 관리</title>
      <link>https://ddd4117.github.io/2021/04/os-4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/</link>
      <pubDate>Mon, 19 Apr 2021 22:03:56 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/04/os-4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[OS] 3장 - Process</title>
      <link>https://ddd4117.github.io/2021/04/os-3%EC%9E%A5-process/</link>
      <pubDate>Mon, 12 Apr 2021 20:48:52 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/04/os-3%EC%9E%A5-process/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[OS] 2장 - 컴퓨터 시스템 구조</title>
      <link>https://ddd4117.github.io/2021/04/os-2%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%A1%B0/</link>
      <pubDate>Mon, 05 Apr 2021 17:08:34 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/04/os-2%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%A1%B0/</guid>
      <description>&lt;p&gt;컴퓨터 시스템의 구조에 대해 알아보자&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[OS] 1장 - 운영체제의 개념</title>
      <link>https://ddd4117.github.io/2021/04/os-1%EC%9E%A5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B0%9C%EB%85%90/</link>
      <pubDate>Mon, 05 Apr 2021 16:48:54 +0900</pubDate>
      
      <guid>https://ddd4117.github.io/2021/04/os-1%EC%9E%A5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B0%9C%EB%85%90/</guid>
      <description>&lt;p&gt;운영체제는 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층을 의미한다.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
